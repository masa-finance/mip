# MIP-1: Safeguard Miner-generated data with Enclaves

## Preamble

- **MIP Number**: #1
- **Title**: Safeguard Miner-generated data with Enclaves
- **Author(s)**: @mudler, @teslashibe
- **Type**: Standards Track
- **Status**: Draft
- **Created**: 21-10-2024
- **Version**: 0.1

## Summary

This proposal aim to give a general understanding of the current state, the problem and the proposed solution. 

The proposal is to move the current code around scraping in its own binary which runs in a TEE enclave.

From Wikipedia [[source]](https://en.wikipedia.org/wiki/Trusted_execution_environment): 
> A trusted execution environment (TEE) is a secure area of a main processor. It helps the code and data loaded inside it be protected with respect to confidentiality and integrity. Data confidentiality prevents unauthorized entities from outside the TEE from reading data, while code integrity prevents code in the TEE from being replaced or modified by unauthorized entities, which may also be the computer owner itself as in certain DRM schemes described in Intel SGX. 

TEE Enclaves also provide a way to sign binary and to verify that the binary is running in a secure environment, and the code is not tampered with, guaranteeing that every client which runs the code is running the same code.

This will allow the miner to run the scraping code in a secure environment, and only expose the results to in an encrypted form to the oracle and the subnet components. Any user of the network which want to request the data will have to de-crypt the content with the same component, in an enclave, which is the only one able to decrypt the content.

This guarantees that the data is not tampered with, and that the data is not exposed to any other component than the one requesting it. The majority of the network users will act as a "barrier" as they require the data to be encrypted when circulating over the p2p layers.

## Motivation

Currently, for an attacker, it's possible to modify the source code of the miner (oracle, and subnet) to send false data to the network. This is a big problem as the network is relying on the data to be correct. The subnet and the oracle are not able to verify the data all the times. In certain cases we adopted a failsafe solution where we double check the data result, but that is not possible in all the cases and increases the "bandwidth" of the network as verifiers should basically verify the same data by trying to scrape it again (in a form or another). This means that basically we *double* the requests as there is one to generate the data, and another one to generate again the data and compare it with the one generated by the miner.

While this approach works, it's not optimal and it's not scalable. The network should be able to trust the data generated by the miner, and the miner should be able to trust the data generated by the oracle.

## Specification

This change should be approached into phases:

- First we move the scraping code outside of the oracle into a separate binary (hereby called "masa-tee-scraper")
- The oracle should start the separate binary ("masa-tee-scraper"), or require it to be started and communicate with it in some way (for instance by specifying the URL where the scraper is running)
- The new binary ("masa-tee-scraper") should run in an enclave, and encrypt all the data it generates as result with the Enclave Product Key.
- The oracle should be able to decrypt the data with the same Enclave Product Key by passing by the encrypted data to "masa-tee-scraper" which can unencrypt it and return the result for the oracle to use.

## Rationale

After some experimenting and research, we found that the best way to secure the data is to use enclaves. Enclaves are a secure environment where the code runs in a secure environment, and the data is encrypted and decrypted in the same environment. This guarantees that the data is not tampered with, and that the data is not exposed to any other component than the one requesting it. The majority of the network users will act as a "barrier" as they require the data to be encrypted when circulating over the p2p layers. Subnet and oracle code then can score and give low or zero rewards to the miners which are not returning encrypted data (that can be decrypted and verified from the code which runs in the enclave).

We don't need to implement Remote attestation at this point either - the data which circulates in the network would be entirely encrypted and can be decrypted only by users which run the masa-tee-scraper binary.

## Backwards Compatibility

This change is NOT backward compatible. As such should be treated with caution and proper documentation should be provided to the users of the network. We could setup a new parallel network to test the new changes, and then migrate the current network to the new one once the changes are tested and verified.

## Implementation

The idea behind this proposal is to create a micro-service which the oracle can call to scrape the data. 

This micro-service will run in an enclave and will encrypt the data before sending it back to the oracle or the subnet. The oracle will act as a proxy and forward the encrypted response back to the subnet which forwards it back to the bittensor network. The node resulting data, to read the work package needs to have a masa-oracle binary running the signed  **masa-tee-scraper** which will be able to decrypt the data. The oracle can serve via the REST API decrypted data directly, but it will have to be encrypted in the p2p layer and decrypted by calling the **masa-tee-scraper** binary.

Further improvements to this proposal could be to implement a remote attestation mechanism to verify the integrity of the enclave and a way to avoid reply-attacks by using a nonce (generated by the node that requests the data) in the encrypted request and response which can be verified by the requester.

These components can all run in a containerized environment, and we can use tools like `docker-compose` to orchestrate the containers and ease out the user experience.

To understand the challanges and the implementation of the new binary ("masa-tee-scraper") we need to understand the current state of the network and how the data is scraped and distributed. 

### Current state 

We can summarize the current architecture of scraping the data in the oracle and in the subnet repositories in the following image, representing the path that a request coming from the bittensor network takes to get the data from the miner:

![mip-tee-current state](https://github.com/user-attachments/assets/5716cc68-5758-427a-a3fe-d94b7b8a880f)

1. A request is originated from the bittensor network, which is received by the subnet
2. The subnet forwards the request to the oracle which is responsible for the data scraping
3. The oracle distributes the work among the peers in the oracle network. The result is then sent back to the subnet
4. (not shown in the image) The subnet then sends the data to the requesting peer and a reward is calculated for the miner which generated the data

### Scope of work

The scope of work for this proposal is to move the scraping code from the oracle and subnet repositories into a new microservice, which will be responsible for scraping the data and encrypting it. The new code can be in a new repository will be called "masa-tee-scraper" or either living in the same codebase, however, we need a separate binary ( that we refer to **masa-tee-scraper** from now on) that will run in an enclave.

The **masa-tee-scraper** will provide an API which can be used by the oracle to scrape the data and decrypt it. The Oracle code will have to be modified to be just the transport layer, and at the same time a client for the masa-tee-scraper API. 

The masa-tee-scraper will run in an enclave and will encrypt the data before sending it back to the oracle or the subnet. Both the request and the responses for data scraping will be encrypted: the data which will circulate in the network will be completely encrypted by this new component which will use the TEE Enclave Product Keys (the implication is that only binaries signed by the same authority are able to decrypt and encrypt the data circulating over the wire).

The consumers of the data (e.g. who is finally reading its content) will have to decrypt-it by using its local instance of the masa-tee-scraper.

Dockerfiles and docker-compose files will be provided to run the components in a containerized environment along the others. The oracle will have to accept arguments such as host and port of the masa-tee-scraper.

We will consider two types of hosts: 

- A host (**Client**) that sends a request to scrape a certain data (e.g. a set of tweets) 
- Another host (**Miner**) that processes the data and sends back the results ( scrapes Twitter APIs and sends back the generated results ).

![mip-tee-proposedstate](https://github.com/user-attachments/assets/31708790-a170-4d0d-b638-a837bca269cd)

1. A request is originated from the bittensor network, which is received by the subnet
2. The subnet forwards the request to the oracle which is responsible for the data scraping. The oracle distributes the work among the peers in the oracle network. 
3. A node of the oracle network takes the job request
4. The oracle scrapes via the masa-tee-scraper service. The (encrypted) result is then sent back as reply to the oracle.
5. The oracle sends the encrypted data back to the client which initiated the scraping request
6. The oracle in the client node receives the request from the oracle network and forwards it to the masa-tee-scraper service to decrypt the data. If the data in masa-oracle isn't encrypted it is discarded as invalid. The majority of the nodes in the network has to act as a barrier to prevent invalid data to be circulated in the network.
7. The decrypted data is then sent back to the client which initiated the scraping request (oracle)
8. The subnet then sends the data to the requesting peer and a reward is calculated for the miner which generated the data

#### Exchange protocol for the masa-tee-scraper

- A client (oracle or subnet)  Generate job request, send to teescraper
- Teescraper generates an encrypted version of request with a nonce
- Request is sent back to the untrusted party - that could manipulate cleartext data
- Request is picked up and run by the tee scraper on another node, an encrypted response is generated 
- Response is sent back to the channel
- Response is decrypted by tee scraper along with the encrypted request: The tee scraper verifies here that the response is associated with the request (by checking the nonce) and decrypts it, otherwise it fails

Both oracle and subnet has to work with encrypted content in the delivery process

Possible API endpoints for the masa-tee-scraper:

- /job - POST - to send a job request
  A job request has a type (string) and a map[string]interface{} as parameter.
- /job/{job_id} - GET - to get the status of a job
- /job/{job_id}/result - GET - to get the result of a job (encrypted)
- /job/{job_id}/status - GET - to get the status of a job (not encrypted)
- /decrypt - POST - to decrypt a message
  Decripts a message. Takes two parameters: the encrypted result and the encrypted request (both strings)

#### Key Management and rotation

The binary is expected to be signed with `ego`. `ego sign` can sign a binary by using a keypair. The keypair can be generated with OpenSSL, by running the following command:

```bash
openssl genrsa -out private.pem -3 3072
```

The public key can be shared with the oracle and the subnet, even if not strictly needed, and the private key should be kept secret.

The public key can be used to verify that the binary is signed by the same authority.

**Rotation** The keypair can be rotated by generating a new keypair and sharing the new public key with the oracle and the subnet, and generating a new binary signed with the new private key.

**Attention**: When rotating keys the protocol version should be updated because the new binary will not be able to decrypt the data encrypted by the binaries which are signed by the old keys.

The key used to sign the binary are used to derive the Enclave Product Key, which is used to encrypt and decrypt the results of the tee-worker's jobs.

### Considered alternatives

We have considered the alternative of running the whole masa-oracle binary inside a TEE enclave. This would be a more secure solution, but it would require a lot of work to move the whole codebase into the enclave, including a more severe challenge (see details below). We have decided to go with the current proposal as it requires less work and it's more feasible to implement in the short term.

#### Challenges in moving the whole masa-oracle binary into an enclave


While exploring TEE enclaves we decided to use the Ego framework as it's a wrapper around open enclaves (https://github.com/edgelesssys/ego) directly usable from go. Other options include using marblerun or scons, however these not provide direct golang support, but would operate on a higher level of abstraction (e.g. using docker containers which are verified to run in an enclave). Since the purpose is to leverage TEE internals ( to decrypt and encrypt data, rather then be concerned of local, runtime security), we decided to go with Ego.

The biggest challenge we have been facing with is that syscalls are forbidden inside enclaves.

The Ego project it looks like basically they re-implement certain syscalls to keep compatibility. The problem with that is the libp2p code does several syscalls even to get information about devices available in the node ( e.g. it calls net.Interfaces, https://cs.opensource.google/go/go/+/refs/tags/go1.23.2:src/net/interface_linux.go ), to say at least.

One way to tackle this is start to re-implement syscalls that libp2p needs in away that are working inside the enclave (by e.g. not doing syscalls, or by exiting the enclave temporarly to execute the syscall, which could have security implications). While this might be the "proper way" of doing it, can be really complex and raise the maintenance bar in the long-term. This is an example of such to implement fd syscalls : https://github.com/edgelesssys/edgelessrt/commit/a967baf367fd4f62ddc7f4e78657fb9e17ee0f45 . That would likely include or upstreaming the syscalls we need or fork the edgelessrt component (part of the ego stack).

For sake of esperimenting, an example PR of trying to run the whole oracle inside a TEE is available here: https://github.com/masa-finance/masa-oracle/pull/588 however, it fails in its current state as the underlying libp2p libraries try to do syscalls which are not allowed in the enclave (trying to get network interfaces ) and fails.

### Hardware requirements and general availability

Intel SGX is one of the most common TEE technology available and it's well adopted in the industry. However, Intel SGX has not to be confused with Intel TPM. Intel TPM technology is widely spread out also in consumer-grade hardware. Intel SGX instruction sets were initially available on a set of consumer-grade target platform as well, but now it has been incorporated with the Intel Xeon processor families, thus it's mostly available on industrial hardware. As of today (2024) latest SGX generations are available on Xeon hardware (e.g. Gold). 

There are cloud providers providing explicit support to Intel SGX, for instance:

- Microsoft Azure has confidential computing offering ( https://learn.microsoft.com/en-us/azure/confidential-computing/virtual-machine-solutions-sgx ), suggested *_DC_v3 series_.
- Alibaba cloud has vSGX instances ( https://www.alibabacloud.com/help/en/ecs/user-guide/build-an-sgx-encrypted-computing-environment ),  g7t, c7t, and r7t instance families.
- OVH Has support for Intel SGX as well ( https://us.ovhcloud.com/bare-metal/intel-software-guard-extensions/ ), but there are no information on the specific instances which supports it. However they provide baremetal solutions and it is possible to enable it from the BIOS by accessing it via KVM. Check for Xeon chipsets which supports SGX instructions.

Alibaba cloud was tested by the authors of this proposal and it's confirmed to work with the Ego framework (**r7t** instances).

### Action items

- [ ] Verify that we can do this by creating a small PoC of a website scraper running in a TEE encrypting the resulting data and serving it back. It will also have to decrypt the data and serve it back.
- [ ] Separate the scraping code from the oracle
- [ ] Create a new binary which runs in an enclave and encrypts the data
- [ ] The new binary will have to expose an API which the oracle can call to get the data (gRPC, REST, etc)
- [ ] The masa-tee-scraper service will have to be able to scrape with the current scrapers supported (e.g. Twitter, Telegram, Discord) and serve back the result via API (encrypted)
- [ ] The masa-tee-scraper service will have to be able to decrypt the data and serve an endpoint to the oracle(or subnet) to decrypt the data
- [ ] The oracle will have to be able to decrypt the data by calling the new binary
- [ ] The subnet will have to be able to decrypt the data by calling the oracle or directly the masa-tee-scraper (technical implementation details to be discussed)

## Copyright

This work is licensed under the Apache-2.0 License.
